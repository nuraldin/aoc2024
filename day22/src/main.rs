/*
 Advent of Code 2024 Day 22: Monkey Market

 There are pseudorandom prices for selling good hiding spots for monkeys.
 Each sequence has a secret of how these are picked. Every secret number evolves into the next secret number.
 The process is in this sequence, i.e. every new secret number one is used in the order:
  - Multiply the secret number by 64, then mix the result into the secret number. Finally, prune the number.
  - Divide the secret number by 32. Round the result down, then mix the result into the secret number. Finally, prune the number.
  - Multiply the secret number by 2048. Then mix the result into the secret number. Finally, prune the secret number.

 Mixing: calculate the bitwise XOR between the value and the secret number.
 Pruning: calculate the modulo 16777216 of the secret number. 

 The puzzle input is the initial secret number of each buyer.
 In a single day each buyer has time to generate 2000 new secret numbers.

 Part one:

 Simulate the creation for eachbuyer of 2000 new secret numbers. 
 What is the sum of the 2000th secret number generated by each buyer?

 Part two:

 The prices the buyer offers are just the first digit of each of the secret numbers.
 e.g. 3 (from 123). Which is the number of banans the buyer is offereing in exchange of the new hiding spot info.
 The selling occurs when a specific sequence of changes in prices occur.
 These are specifically four consecutive changes in price.
 If the seller never sees that sequence in the price changes it will not sell and move on to next buyer.
 I can only give one single sequence to the seller. The sequence doesn't change between buyers.
 I need to determine which sequence of four price changes will cause the monkey to get the most bananas overall.

 With that four number sequence, What is the most bananas I can get?
*/
use utils::{ChallengeConfig, ChallengePart};

fn prune(n: u64) -> u64 {
  n.rem_euclid(16777216)
}

fn mix(n: u64, m: u64) -> u64 {
  n ^ m
}

fn first_step(n: u64) -> u64 {
  let m = n * 64;
  let r = mix(n, m);
  prune(r)
}

fn second_step(n: u64) -> u64 {
  let m = n / 32;
  let r = mix(n, m);
  prune(r)
}

fn third_step(n: u64) -> u64 {
  let m = n * 2048;
  let r = mix(n, m);
  prune(r)
}

fn get_next_secret_number(n: u64) -> u64 {
  third_step(second_step(first_step(n)))
}

fn main() {
    let challenge_config = ChallengeConfig::get();
    
    let puzzle_input = parse_input(&challenge_config);

    match challenge_config.part {
      ChallengePart::One => println!("The sum of the 2000th secret number generated by each buyer is: {}", calculate_sum_of_secret_numbers(puzzle_input)),
      ChallengePart::Two => println!("Not implemented yet"),
    }
}

fn parse_input(config: &ChallengeConfig) -> Vec<u64> {
  let mut secret_numbers = vec![];

  for line in config.read_puzzle_input(None) {
    secret_numbers.push(line.parse().unwrap())
  }

  secret_numbers
} 

fn get_nth_secret_number(m: u64, n: u64) -> u64 {
  let mut result = m;

  for _ in 0..n {
    result = get_next_secret_number(result);
  }

  result
}

fn calculate_sum_of_secret_numbers(ns: Vec<u64>) -> u64 {
  let mut result = 0;

  for n in ns {
    result += get_nth_secret_number(n, 2000);
  }

  result
}

#[cfg(test)]
mod tests {
  use utils::TEST_CONFIG;

use super::*;

  #[test]
  fn pruning_works() {
    let secret_number = 100000000;
    assert_eq!(prune(secret_number), 16113920);
  }

  #[test]
  fn mixing_works() {
    let secret_number = 42;
    let mixing_number = 15;

    assert_eq!(mix(secret_number, mixing_number), 37);
  }

  #[test]
  fn first_step_works() {
    let secret_number = 123;

    assert_eq!(get_next_secret_number(secret_number), 15887950);
  }

  #[test]
  fn example_first_ten_secret_numbers_works() {
    let next_numbers = [15887950, 16495136, 527345, 704524, 1553684, 12683156, 11100544, 12249484, 7753432, 5908254];
    let mut secret_number = 123;

    for next_number in next_numbers {
      secret_number = get_next_secret_number(secret_number);

      assert_eq!(secret_number, next_number);
    }
  }

  #[test] 
  fn example_input_for_2000th_works() {
    let example_input = parse_input(&TEST_CONFIG);
    let results = [8685429, 4700978, 15273692, 8667524];

    for (idx, result) in results.iter().enumerate() {
      assert_eq!(get_nth_secret_number(example_input[idx], 2000), *result);
    }
  }

  #[test]
  fn example_input_result_works() {
    let example_input = parse_input(&TEST_CONFIG);
    assert_eq!(calculate_sum_of_secret_numbers(example_input), 37327623);
  }
}